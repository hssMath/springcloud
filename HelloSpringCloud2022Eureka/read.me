rpc 远程过程调用：
    rpd 是长连接：客户端与服务端建立连接通信后，可以长时间的通信。不需要通信一次,需要进行先连接3次握手和断开4次挥手。
    http（超文本传输协议） 是短连接：1.连接3此握手（客户端发送请求找服务端等待响应；服务端告诉客户已就绪；客户端告诉服务器，收到）；
                2.断开链接是4次挥手（客户端发送断开请求给服务端；服务器收到关闭请求；服务端关闭连接后告诉客户端；客户端回复收到）。

1、什么是服务治理：
    Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理，在传统的 rpc 远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，
        所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。
2、Eureka包含两个组件：Eureka Server和Eureka Client
    2.1 EurekaServer 提供服务注册服务
    各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。
    2.2 EurekaClient 通过注册中心进行访问，是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。
    在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这
    个服务节点移除（默认90秒）
eureka工作流程：
    1、eureka 将服务信息注册进服务配置中心，实际是将服务名为 key，value为调用地址的键值对存进 eurekaServer 中，eureka 就会从注册中心获取服务信息。
    2、单机版工作流程：
        2.1 先启动eureka注册中心
        2.2 启动服务提供者payment支付服务
        2.3 支付服务启动后会把自身信息(比如服务地址以别名方式注册进eureka)
        2.4 消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址
        2.5 消费者获取调用地址（底层实际是利用 HttpClient 技术实现远程调用）
        2.6 消费者获得服务地址后会缓存在本地 jvm 内存中，默认每间隔30秒更新一次服务调用地址
    3、微服务RPC远程调用服务最核心的是:高可用。
        解决办法：搭建eureka注册中心集群，实现负载均衡、故障容错。
        实现原理：互相注册，相互守望：cloud-eureka-server7002 与 cloud-eureka-server7001 实现集群，关联关系：服务调用地址互相交叉
    4、集群版工作流程(了解完 Eureka 核心概念，自我保护机制，以及集群内的工作原理后，我们来整体梳理一下 Eureka 的工作流程)：
        4.1 Eureka Server 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 Replicate 同步注册表，每个 Eureka Server 都存在独立完整的服务注册表信息
        4.2 Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务
        4.3 Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常
        4.4 当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例
        4.5 单位时间内 Eureka Server 统计到有大量的 Eureka Client 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端
        4.6 当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式
        4.7 Eureka Client 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地
        4.8 服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存
        4.9 Eureka Client 获取到目标服务器信息，发起服务调用
        4.10 Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除
    5、自我保护机制
      默认情况下，如果 Eureka Server 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着
      各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。固定时间内大量实例被注销，可能会严重威胁整个微服务架构的可用性。为了解决这个问题，Eureka 开发了自
      我保护机制，那么什么是自我保护机制呢？
      Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 即会进入自我保护机制。Eureka Server 触发自我保护
      机制后，页面会出现提示：
    6、Eureka Server 进入自我保护机制，会出现以下几种情况：
      (1 Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
      (2 Eureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)
      (3 当网络稳定时，当前实例新的注册信息会被同步到其它节点中
      Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 Eureka 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，Eureka 会自动退出自我保护机制。
      如果在保护期内刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，即会调用失败。对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。
      通过在 Eureka Server 配置如下参数，开启或者关闭保护机制，生产环境建议打开。
    7、Eureka 集群原理：
      再来看看 Eureka 集群的工作原理。我们假设有三台 Eureka Server 组成的集群，第一台 Eureka Server 在北京机房，另外两台 Eureka Server 在深圳和西安机房。这样三台 Eureka Server 就组建成了一个跨区域的高可用集群，只要三个地方的任意一个机房不出现问题，都不会影响整个架构的稳定性。
      从图中可以看出 Eureka Server 集群相互之间通过 Replicate 来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点。
      如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点。当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它 Eureka Server 当前所知的所有节点中。
      另外 Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个 Eureka Server 同时也是 Eureka Client，多个 Eureka Server 之间通过 P2P 的方式完成服务注册表的同步。
      Eureka Server 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。
      Eureka 分区
      Eureka 提供了 Region 和 Zone 两个概念来进行分区，这两个概念均来自于亚马逊的 AWS:
      region：可以理解为地理上的不同区域，比如亚洲地区，中国区或者深圳等等。没有具体大小的限制。根据项目具体的情况，可以自行合理划分 region。
      zone：可以简单理解为 region 内的具体机房，比如说 region 划分为深圳，然后深圳有两个机房，就可以在此 region 之下划分出 zone1、zone2 两个 zone。
      上图中的 us-east-1c、us-east-1d、us-east-1e 就代表了不同的 Zone。Zone 内的 Eureka Client 优先和 Zone 内的 Eureka Server 进行心跳同步，同样调用端优先在 Zone 内的 Eureka Server 获取服务列表，当 Zone 内的 Eureka Server 挂掉之后，才会从别的 Zone 中获取信息。
      Eurka 保证 AP
      Eureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka Client 在向某个 Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台 Eureka Server 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。
ribbon（Ribbon其实就是一个软负载均衡的客户端组件）:
    1.概念：
        Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。
        简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。
        Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon 会自动的帮助你基于某种规则（如简单轮询，随机连接等）
        去连接这些机器。我们很容易使用 Ribbon 实现自定义的负载均衡算法。
    2.负载均衡(Load Balance)是什么:
        2.1 简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。常见的负载均衡有软件Nginx，LVS，硬件 F5等。
        2.2 Ribbon 本地负载均衡客户端 VS Nginx服务端负载均衡区别：
            Nginx 是服务器负载均衡，客户端所有请求都会先交给 nginx，然后由 nginx 实现转发请求。即负载均衡是由服务端实现的。
            Ribbon 本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。
    3.作用:负载均衡+RestTemplate 调用
    4.架构说明：
        Ribbon在工作时分成两步
        第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server.
        第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。
        其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。
    5.负载均衡算法原理：

面试点一：负载均衡算法。


1、在传统的 RPC 远程过程调用框架中，管理每个服务与服务之间依赖关系比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，进而实现服务调用、
负载均衡、容错、服务的发现与注册。目前已知的解决方案有 eureka、zookeeper、consul;
2、eureka采用了 C-S 的设计架构，包含两大组件：
   2.1 Eureka Server 提供服务注册功能，各个微服务节点通过配置启动后，会在 Eureka Server 中进行注册，可以通过提供的可视化界面直观看到服务节
        点信息。
   2.2 Eureka Client 是连接 Eureka Server 的一个Java客户端，用于简化与 Eureka Server 的交互，客户端同时也具备一个内置的、默认使用
        轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向 Eureka Server 每30秒发送一个心跳。如果 Eureka Server 在多个心跳周期内
        没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）。
   2.3 Eureka 的自我保护机制(解决问题：当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除
        这个微服务，所以引入了自我保护机制；意义:它不会从注册列表中剔除因长时间没收到心跳导致租期过期的服务，而是等待修复，直到心跳恢复正常之后，它自动退出自我保护模式。这种模式旨在避免因网络分区故障导致服务不可用的问题。)：在应用启动后，Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 会将这些实例保护起来，让这些实例不会过期，但是在保护期内如果服务刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，此时会调用失败，对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。
   3、CAP理论指的是一个分布式系统不可能同时很好的满足一致性、可用性、分区容错性，最多只能同时较好的满足其中的2个，CAP理论关注粒度是数据，而不是
        整体系统设计的策略；eureka 属于 AP （高可用、分区容错性）：当多个微服务的服务提供者没有出现网络分区时，多个微服务的数据是一致的的，若
        有单个出现网络分区与其余系统网络分区不一致时，系统之间的数据同步就会失败，此时 eureka 服务注册中心为了保证系统的可用性，系统为了响应请
        求返回一个旧值，保证系统的可用性，因为其违背了一致性C的要求，只满足了可用性和分区容错性即AP；zookeeper 和 consul 属于CP,当多个微服
        务的服务提供者没有出现网路分区时，多个微服务的数据是一致的，若其中出现网络分区与其余系统的网络分区不一致时，系统之间的数据同步就会失效，此时 Zookeeper 和 Consul 为了数据的一致性，出现网络分区的服务会拒绝服务请求，会返回错误码或者错误信息。